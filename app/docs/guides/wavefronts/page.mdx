# Волновые фронты

import { Callout, Tabs } from 'nextra/components'

Класс `Wavefront` представляет комплексную амплитуду электромагнитного поля $E(x, y)$. Это основной объект, с которым работают все оптические элементы.

## Наследование от torch.Tensor

`Wavefront` наследует `torch.Tensor`, поэтому поддерживает все тензорные операции:

```python
from svetlanna import Wavefront

# Арифметика
wf_sum = wf1 + wf2        # Интерференция
wf_scaled = wf * 0.5      # Ослабление
wf_conj = wf.conj()       # Комплексное сопряжение

# Перенос на GPU
wf_gpu = wf.to("cuda")

# Индексация
wf_slice = wf[100:400, 100:400]
```

---

## Фабричные методы

### Плоская волна

```python
wf = Wavefront.plane_wave(params)
```

Создаёт волну с единичной амплитудой и нулевой фазой:
$$E(x, y) = 1$$

### Гауссов пучок

<Tabs items={['Базовый', 'Со смещением', 'На расстоянии']}>
  <Tabs.Tab>
```python
from svetlanna import Wavefront
from svetlanna.units import ureg

wf = Wavefront.gaussian_beam(params, waist_radius=0.5*ureg.mm)
```

Гауссово распределение интенсивности:
$$E(x, y) = \exp\left(-\frac{x^2 + y^2}{w_0^2}\right)$$
  </Tabs.Tab>
  <Tabs.Tab>
```python
# Гауссов пучок со смещением центра
wf = Wavefront.gaussian_beam(
    params,
    waist_radius=0.5*ureg.mm,
    dx=0.2*ureg.mm,  # Смещение по X
    dy=0.1*ureg.mm   # Смещение по Y
)
```
  </Tabs.Tab>
  <Tabs.Tab>
```python
# Гауссов пучок на расстоянии от перетяжки
wf = Wavefront.gaussian_beam(
    params,
    waist_radius=0.5*ureg.mm,
    distance=10*ureg.mm  # Расстояние от перетяжки
)
```
  </Tabs.Tab>
</Tabs>

**Параметры:**

| Параметр | Описание | По умолчанию |
|----------|----------|--------------|
| `waist_radius` | Радиус перетяжки $w_0$ | — |
| `distance` | Расстояние от перетяжки | `0.0` |
| `dx`, `dy` | Смещение центра | `0.0` |

### Сферическая волна

```python
wf = Wavefront.spherical_wave(params, distance=50*ureg.mm)
```

Сходящаяся (distance > 0) или расходящаяся (distance < 0) сферическая волна:
$$E(x, y) = \exp\left(-i \frac{k}{2R}(x^2 + y^2)\right)$$

где $R$ — радиус кривизны (distance).

### Создание из тензора

```python
import torch

# Пользовательское распределение
amplitude = torch.ones(512, 512)
phase = torch.zeros(512, 512)
complex_field = amplitude * torch.exp(1j * phase)

wf = Wavefront(complex_field)
```

<Callout type="info">
При создании из тензора `Wavefront` автоматически приводит тип к `complex64`.
</Callout>

---

## Свойства

| Свойство | Описание | Формула |
|----------|----------|---------|
| `wf.intensity` | Интенсивность | $I = \|E\|^2$ |
| `wf.phase` | Фаза (радианы) | $\phi = \arg(E)$ |
| `wf.max_intensity` | Максимум интенсивности | $\max(I)$ |

### Интенсивность

```python
I = wf.intensity  # |E|²
```

Возвращает квадрат модуля комплексной амплитуды.

### Фаза

```python
phi = wf.phase  # arg(E)
```

Возвращает фазу в радианах от $-\pi$ до $\pi$.

### Максимальная интенсивность

```python
I_max = wf.max_intensity
```

Эквивалентно `wf.intensity.max()`.

### FWHM

```python
fwhm_x, fwhm_y = wf.fwhm(params)
```

Полная ширина на полувысоте (Full Width at Half Maximum) по осям X и Y.

```python
# Перевод в микрометры
print(f"FWHM: {fwhm_x*1e6:.2f} × {fwhm_y*1e6:.2f} мкм")
```

---

## Операции над волновыми фронтами

### Интерференция

```python
# Сложение двух волн — интерференция
wf_interference = wf1 + wf2

# Интерференционная картина
I_interference = wf_interference.intensity
```

### Модуляция амплитуды

```python
# Ослабление
wf_attenuated = wf * 0.5

# Усиление
wf_amplified = wf * 2.0

# Маска пропускания (0 или 1)
X, Y = params.meshgrid(x_axis='W', y_axis='H')
radius = 0.5e-3
mask = (X**2 + Y**2 < radius**2).float()
wf_masked = wf * mask
```

### Модуляция фазы

```python
import torch

# Добавление фазы
phase_shift = torch.pi / 4
wf_shifted = wf * torch.exp(1j * phase_shift)

# Пространственная фазовая модуляция
phase_mask = create_phase_mask(params)  # ваша функция
wf_modulated = wf * torch.exp(1j * phase_mask)
```

---

## Визуализация

```python
import matplotlib.pyplot as plt

fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Extent для правильных осей
extent = [
    params.axes.W[0].item()*1e3, params.axes.W[-1].item()*1e3,
    params.axes.H[0].item()*1e3, params.axes.H[-1].item()*1e3
]

# Интенсивность
im0 = axes[0].imshow(wf.intensity.cpu(), cmap='hot', extent=extent, origin='lower')
axes[0].set_title('Интенсивность')
axes[0].set_xlabel('x, мм')
axes[0].set_ylabel('y, мм')
plt.colorbar(im0, ax=axes[0])

# Фаза
im1 = axes[1].imshow(wf.phase.cpu(), cmap='twilight', extent=extent, origin='lower')
axes[1].set_title('Фаза')
axes[1].set_xlabel('x, мм')
axes[1].set_ylabel('y, мм')
plt.colorbar(im1, ax=axes[1])

plt.tight_layout()
plt.show()
```

---

## Многомерные волновые фронты

При использовании нескольких длин волн волновой фронт автоматически становится многомерным:

```python
import torch
from svetlanna import SimulationParameters, Wavefront

# Три длины волны (RGB)
params = SimulationParameters(
    W=torch.linspace(-1e-3, 1e-3, 256),
    H=torch.linspace(-1e-3, 1e-3, 256),
    wavelength=torch.tensor([630, 532, 465]) * 1e-9
)

wf = Wavefront.gaussian_beam(params, waist_radius=0.3e-3)
print(wf.shape)  # torch.Size([3, 256, 256])

# Доступ к отдельным длинам волн
wf_red = wf[0]    # 630 нм
wf_green = wf[1]  # 532 нм
wf_blue = wf[2]   # 465 нм
```

<Callout type="warning">
При многомерных расчётах все оптические элементы автоматически применяются к каждой длине волны с учётом дисперсии.
</Callout>

---

## Пример: суперпозиция мод

```python
import torch
from svetlanna import SimulationParameters, Wavefront
from svetlanna.units import ureg

params = SimulationParameters.from_ranges(
    w_range=(-2*ureg.mm, 2*ureg.mm), w_points=512,
    h_range=(-2*ureg.mm, 2*ureg.mm), h_points=512,
    wavelength=632.8*ureg.nm
)

# Суперпозиция двух гауссовых пучков
wf1 = Wavefront.gaussian_beam(params, waist_radius=0.5*ureg.mm)
wf2 = Wavefront.gaussian_beam(params, waist_radius=0.3*ureg.mm)

# Сдвиг по фазе
wf2 = wf2 * torch.exp(1j * torch.pi / 2)

# Интерференция
wf_super = wf1 + wf2

# Интерференционная картина
I = wf_super.intensity
print(f"Максимальная интенсивность: {I.max():.4f}")
```

---

## GPU-ускорение

```python
# Перенос на GPU
wf_gpu = wf.to('cuda')

# Или при создании через params
params.to('cuda')
wf = Wavefront.gaussian_beam(params, waist_radius=0.5e-3)  # Автоматически на GPU
```

---

## См. также

- [SimulationParameters](/docs/guides/simulation-parameters) — настройка координат
- [Оптические элементы](/docs/guides/elements) — преобразование волновых фронтов
- [Transforms](/docs/guides/transforms) — преобразование изображений в волновые фронты
